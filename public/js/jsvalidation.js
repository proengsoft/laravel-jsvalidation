/*!
 * jQuery Validation Plugin v1.13.1
 *
 * http://jqueryvalidation.org/
 *
 * Copyright (c) 2014 JÃ¶rn Zaefferer
 * Released under the MIT license
 */
(function( factory ) {
	if ( typeof define === "function" && define.amd ) {
		define( ["jquery"], factory );
	} else {
		factory( jQuery );
	}
}(function( $ ) {

	$.extend($.fn, {
		// http://jqueryvalidation.org/validate/
		validate: function( options ) {
			// if nothing is selected, return nothing; can't chain anyway
			if ( !this.length ) {
				if ( options && options.debug && window.console ) {
					console.warn( "Nothing selected, can't validate, returning nothing." );
				}
				return;
			}

			// check if a validator for this form was already created
			var validator = $.data( this[ 0 ], "validator" );
			if ( validator ) {
				return validator;
			}

			// Add novalidate tag if HTML5.
			this.attr( "novalidate", "novalidate" );

			validator = new $.validator( options, this[ 0 ] );
			$.data( this[ 0 ], "validator", validator );

			if ( validator.settings.onsubmit ) {

				this.validateDelegate( ":submit", "click", function( event ) {
					if ( validator.settings.submitHandler ) {
						validator.submitButton = event.target;
					}
					// allow suppressing validation by adding a cancel class to the submit button
					if ( $( event.target ).hasClass( "cancel" ) ) {
						validator.cancelSubmit = true;
					}

					// allow suppressing validation by adding the html5 formnovalidate attribute to the submit button
					if ( $( event.target ).attr( "formnovalidate" ) !== undefined ) {
						validator.cancelSubmit = true;
					}
				});

				// validate the form on submit
				this.submit( function( event ) {
					if ( validator.settings.debug ) {
						// prevent form submit to be able to see console output
						event.preventDefault();
					}
					function handle() {
						var hidden, result;
						if ( validator.settings.submitHandler ) {
							if ( validator.submitButton ) {
								// insert a hidden input as a replacement for the missing submit button
								hidden = $( "<input type='hidden'/>" )
									.attr( "name", validator.submitButton.name )
									.val( $( validator.submitButton ).val() )
									.appendTo( validator.currentForm );
							}
							result = validator.settings.submitHandler.call( validator, validator.currentForm, event );
							if ( validator.submitButton ) {
								// and clean up afterwards; thanks to no-block-scope, hidden can be referenced
								hidden.remove();
							}
							if ( result !== undefined ) {
								return result;
							}
							return false;
						}
						return true;
					}

					// prevent submit for invalid forms or custom submit handlers
					if ( validator.cancelSubmit ) {
						validator.cancelSubmit = false;
						return handle();
					}
					if ( validator.form() ) {
						if ( validator.pendingRequest ) {
							validator.formSubmitted = true;
							return false;
						}
						return handle();
					} else {
						$.event.trigger({
							type: "laravel-jsvalidation:failedValidation"
						});
						validator.focusInvalid();
						return false;
					}
				});
			}

			return validator;
		},
		// http://jqueryvalidation.org/valid/
		valid: function() {
			var valid, validator;

			if ( $( this[ 0 ] ).is( "form" ) ) {
				valid = this.validate().form();
			} else {
				valid = true;
				validator = $( this[ 0 ].form ).validate();
				this.each( function() {
					valid = validator.element( this ) && valid;
				});
			}
			return valid;
		},
		// attributes: space separated list of attributes to retrieve and remove
		removeAttrs: function( attributes ) {
			var result = {},
				$element = this;
			$.each( attributes.split( /\s/ ), function( index, value ) {
				result[ value ] = $element.attr( value );
				$element.removeAttr( value );
			});
			return result;
		},
		// http://jqueryvalidation.org/rules/
		rules: function( command, argument ) {
			var element = this[ 0 ],
				settings, staticRules, existingRules, data, param, filtered;

			if ( command ) {
				settings = $.data( element.form, "validator" ).settings;
				staticRules = settings.rules;
				existingRules = $.validator.staticRules( element );
				switch ( command ) {
					case "add":
						$.extend( existingRules, $.validator.normalizeRule( argument ) );
						// remove messages from rules, but allow them to be set separately
						delete existingRules.messages;
						staticRules[ element.name ] = existingRules;
						if ( argument.messages ) {
							settings.messages[ element.name ] = $.extend( settings.messages[ element.name ], argument.messages );
						}
						break;
					case "remove":
						if ( !argument ) {
							delete staticRules[ element.name ];
							return existingRules;
						}
						filtered = {};
						$.each( argument.split( /\s/ ), function( index, method ) {
							filtered[ method ] = existingRules[ method ];
							delete existingRules[ method ];
							if ( method === "required" ) {
								$( element ).removeAttr( "aria-required" );
							}
						});
						return filtered;
				}
			}

			data = $.validator.normalizeRules(
				$.extend(
					{},
					$.validator.classRules( element ),
					$.validator.attributeRules( element ),
					$.validator.dataRules( element ),
					$.validator.staticRules( element )
				), element );

			// make sure required is at front
			if ( data.required ) {
				param = data.required;
				delete data.required;
				data = $.extend( { required: param }, data );
				$( element ).attr( "aria-required", "true" );
			}

			// make sure remote is at back
			if ( data.remote ) {
				param = data.remote;
				delete data.remote;
				data = $.extend( data, { remote: param });
			}

			return data;
		}
	});

// Custom selectors
	$.extend( $.expr[ ":" ], {
		// http://jqueryvalidation.org/blank-selector/
		blank: function( a ) {
			return !$.trim( "" + $( a ).val() );
		},
		// http://jqueryvalidation.org/filled-selector/
		filled: function( a ) {
			return !!$.trim( "" + $( a ).val() );
		},
		// http://jqueryvalidation.org/unchecked-selector/
		unchecked: function( a ) {
			return !$( a ).prop( "checked" );
		}
	});

// constructor for validator
	$.validator = function( options, form ) {
		this.settings = $.extend( true, {}, $.validator.defaults, options );
		this.currentForm = form;
		this.init();
	};

// http://jqueryvalidation.org/jQuery.validator.format/
	$.validator.format = function( source, params ) {
		if ( arguments.length === 1 ) {
			return function() {
				var args = $.makeArray( arguments );
				args.unshift( source );
				return $.validator.format.apply( this, args );
			};
		}
		if ( arguments.length > 2 && params.constructor !== Array  ) {
			params = $.makeArray( arguments ).slice( 1 );
		}
		if ( params.constructor !== Array ) {
			params = [ params ];
		}
		$.each( params, function( i, n ) {
			source = source.replace( new RegExp( "\\{" + i + "\\}", "g" ), function() {
				return n;
			});
		});
		return source;
	};

	$.extend( $.validator, {

		defaults: {
			messages: {},
			groups: {},
			rules: {},
			errorClass: "error",
			validClass: "valid",
			errorElement: "label",
			focusCleanup: false,
			focusInvalid: true,
			errorContainer: $( [] ),
			errorLabelContainer: $( [] ),
			onsubmit: true,
			ignore: ":hidden",
			ignoreTitle: false,
			onfocusin: function( element ) {
				this.lastActive = element;

				// Hide error label and remove error class on focus if enabled
				if ( this.settings.focusCleanup ) {
					if ( this.settings.unhighlight ) {
						this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
					}
					this.hideThese( this.errorsFor( element ) );
				}
			},
			onfocusout: function( element ) {
				if ( !this.checkable( element ) && ( element.name in this.submitted || !this.optional( element ) ) ) {
					this.element( element );
				}
			},
			onkeyup: function( element, event ) {
				if ( event.which === 9 && this.elementValue( element ) === "" ) {
					return;
				} else if ( element.name in this.submitted || element === this.lastElement ) {
					this.element( element );
				}
			},
			onclick: function( element ) {
				// click on selects, radiobuttons and checkboxes
				if ( element.name in this.submitted ) {
					this.element( element );

					// or option elements, check parent select in that case
				} else if ( element.parentNode.name in this.submitted ) {
					this.element( element.parentNode );
				}
			},
			highlight: function( element, errorClass, validClass ) {
				if ( element.type === "radio" ) {
					this.findByName( element.name ).addClass( errorClass ).removeClass( validClass );
				} else {
					$( element ).addClass( errorClass ).removeClass( validClass );
				}
			},
			unhighlight: function( element, errorClass, validClass ) {
				if ( element.type === "radio" ) {
					this.findByName( element.name ).removeClass( errorClass ).addClass( validClass );
				} else {
					$( element ).removeClass( errorClass ).addClass( validClass );
				}
			}
		},

		// http://jqueryvalidation.org/jQuery.validator.setDefaults/
		setDefaults: function( settings ) {
			$.extend( $.validator.defaults, settings );
		},

		messages: {
			required: "This field is required.",
			remote: "Please fix this field.",
			email: "Please enter a valid email address.",
			url: "Please enter a valid URL.",
			date: "Please enter a valid date.",
			dateISO: "Please enter a valid date ( ISO ).",
			number: "Please enter a valid number.",
			digits: "Please enter only digits.",
			creditcard: "Please enter a valid credit card number.",
			equalTo: "Please enter the same value again.",
			maxlength: $.validator.format( "Please enter no more than {0} characters." ),
			minlength: $.validator.format( "Please enter at least {0} characters." ),
			rangelength: $.validator.format( "Please enter a value between {0} and {1} characters long." ),
			range: $.validator.format( "Please enter a value between {0} and {1}." ),
			max: $.validator.format( "Please enter a value less than or equal to {0}." ),
			min: $.validator.format( "Please enter a value greater than or equal to {0}." )
		},

		autoCreateRanges: false,

		prototype: {

			init: function() {
				this.labelContainer = $( this.settings.errorLabelContainer );
				this.errorContext = this.labelContainer.length && this.labelContainer || $( this.currentForm );
				this.containers = $( this.settings.errorContainer ).add( this.settings.errorLabelContainer );
				this.submitted = {};
				this.valueCache = {};
				this.pendingRequest = 0;
				this.pending = {};
				this.invalid = {};
				this.reset();

				var groups = ( this.groups = {} ),
					rules;
				$.each( this.settings.groups, function( key, value ) {
					if ( typeof value === "string" ) {
						value = value.split( /\s/ );
					}
					$.each( value, function( index, name ) {
						groups[ name ] = key;
					});
				});
				rules = this.settings.rules;
				$.each( rules, function( key, value ) {
					rules[ key ] = $.validator.normalizeRule( value );
				});

				function delegate( event ) {
					var validator = $.data( this[ 0 ].form, "validator" ),
						eventType = "on" + event.type.replace( /^validate/, "" ),
						settings = validator.settings;
					if ( settings[ eventType ] && !this.is( settings.ignore ) ) {
						settings[ eventType ].call( validator, this[ 0 ], event );
					}
				}
				$( this.currentForm )
					.validateDelegate( ":text, [type='password'], [type='file'], select, textarea, " +
					"[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
					"[type='email'], [type='datetime'], [type='date'], [type='month'], " +
					"[type='week'], [type='time'], [type='datetime-local'], " +
					"[type='range'], [type='color'], [type='radio'], [type='checkbox']",
					"focusin focusout keyup", delegate)
					// Support: Chrome, oldIE
					// "select" is provided as event.target when clicking a option
					.validateDelegate("select, option, [type='radio'], [type='checkbox']", "click", delegate);

				if ( this.settings.invalidHandler ) {
					$( this.currentForm ).bind( "invalid-form.validate", this.settings.invalidHandler );
				}

				// Add aria-required to any Static/Data/Class required fields before first validation
				// Screen readers require this attribute to be present before the initial submission http://www.w3.org/TR/WCAG-TECHS/ARIA2.html
				$( this.currentForm ).find( "[required], [data-rule-required], .required" ).attr( "aria-required", "true" );
			},

			// http://jqueryvalidation.org/Validator.form/
			form: function() {
				this.checkForm();
				$.extend( this.submitted, this.errorMap );
				this.invalid = $.extend({}, this.errorMap );
				if ( !this.valid() ) {
					$( this.currentForm ).triggerHandler( "invalid-form", [ this ]);
				}
				this.showErrors();
				return this.valid();
			},

			checkForm: function() {
				this.prepareForm();
				for ( var i = 0, elements = ( this.currentElements = this.elements() ); elements[ i ]; i++ ) {
					this.check( elements[ i ] );
				}
				return this.valid();
			},

			// http://jqueryvalidation.org/Validator.element/
			element: function( element ) {
				var cleanElement = this.clean( element ),
					checkElement = this.validationTargetFor( cleanElement ),
					result = true;

				this.lastElement = checkElement;

				if ( checkElement === undefined ) {
					delete this.invalid[ cleanElement.name ];
				} else {
					this.prepareElement( checkElement );
					this.currentElements = $( checkElement );

					result = this.check( checkElement ) !== false;
					if ( result ) {
						delete this.invalid[ checkElement.name ];
					} else {
						this.invalid[ checkElement.name ] = true;
					}
				}
				// Add aria-invalid status for screen readers
				$( element ).attr( "aria-invalid", !result );

				if ( !this.numberOfInvalids() ) {
					// Hide error containers on last error
					this.toHide = this.toHide.add( this.containers );
				}
				this.showErrors();
				return result;
			},

			// http://jqueryvalidation.org/Validator.showErrors/
			showErrors: function( errors ) {
				if ( errors ) {
					// add items to error list and map
					$.extend( this.errorMap, errors );
					this.errorList = [];
					for ( var name in errors ) {
						this.errorList.push({
							message: errors[ name ],
							element: this.findByName( name )[ 0 ]
						});
					}
					// remove items from success list
					this.successList = $.grep( this.successList, function( element ) {
						return !( element.name in errors );
					});
				}
				if ( this.settings.showErrors ) {
					this.settings.showErrors.call( this, this.errorMap, this.errorList );
				} else {
					this.defaultShowErrors();
				}
			},

			// http://jqueryvalidation.org/Validator.resetForm/
			resetForm: function() {
				if ( $.fn.resetForm ) {
					$( this.currentForm ).resetForm();
				}
				this.submitted = {};
				this.lastElement = null;
				this.prepareForm();
				this.hideErrors();
				this.elements()
					.removeClass( this.settings.errorClass )
					.removeData( "previousValue" )
					.removeAttr( "aria-invalid" );
			},

			numberOfInvalids: function() {
				var numberOfInvalids = this.objectLength( this.invalid );
				console.log(numberOfInvalids);

				if (numberOfInvalids > 0)
				{
					$.event.trigger({
						type: "laravel-jsvalidation:failedValidation"
					});
				}
				else
				{
					$.event.trigger({
						type: "laravel-jsvalidation:passedValidation"
					});
				}
				return numberOfInvalids;
			},

			objectLength: function( obj ) {
				/* jshint unused: false */
				var count = 0,
					i;
				for ( i in obj ) {
					count++;
				}
				return count;
			},

			hideErrors: function() {
				this.hideThese( this.toHide );
			},

			hideThese: function( errors ) {
				errors.not( this.containers ).text( "" );
				this.addWrapper( errors ).hide();
			},

			valid: function() {
				return this.size() === 0;
			},

			size: function() {
				return this.errorList.length;
			},

			focusInvalid: function() {
				if ( this.settings.focusInvalid ) {
					try {
						$( this.findLastActive() || this.errorList.length && this.errorList[ 0 ].element || [])
							.filter( ":visible" )
							.focus()
							// manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
							.trigger( "focusin" );
					} catch ( e ) {
						// ignore IE throwing errors when focusing hidden elements
					}
				}
			},

			findLastActive: function() {
				var lastActive = this.lastActive;
				return lastActive && $.grep( this.errorList, function( n ) {
						return n.element.name === lastActive.name;
					}).length === 1 && lastActive;
			},

			elements: function() {
				var validator = this,
					rulesCache = {};

				// select all valid inputs inside the form (no submit or reset buttons)
				return $( this.currentForm )
					.find( "input, select, textarea" )
					.not( ":submit, :reset, :image, [disabled], [readonly]" )
					.not( this.settings.ignore )
					.filter( function() {
						if ( !this.name && validator.settings.debug && window.console ) {
							console.error( "%o has no name assigned", this );
						}

						// select only the first element for each name, and only those with rules specified
						if ( this.name in rulesCache || !validator.objectLength( $( this ).rules() ) ) {
							return false;
						}

						rulesCache[ this.name ] = true;
						return true;
					});
			},

			clean: function( selector ) {
				return $( selector )[ 0 ];
			},

			errors: function() {
				var errorClass = this.settings.errorClass.split( " " ).join( "." );
				return $( this.settings.errorElement + "." + errorClass, this.errorContext );
			},

			reset: function() {
				this.successList = [];
				this.errorList = [];
				this.errorMap = {};
				this.toShow = $( [] );
				this.toHide = $( [] );
				this.currentElements = $( [] );
			},

			prepareForm: function() {
				this.reset();
				this.toHide = this.errors().add( this.containers );
			},

			prepareElement: function( element ) {
				this.reset();
				this.toHide = this.errorsFor( element );
			},

			elementValue: function( element ) {
				var val,
					$element = $( element ),
					type = element.type;

				if ( type === "radio" || type === "checkbox" ) {
					return $( "input[name='" + element.name + "']:checked" ).val();
				} else if ( type === "number" && typeof element.validity !== "undefined" ) {
					return element.validity.badInput ? false : $element.val();
				}

				val = $element.val();
				if ( typeof val === "string" ) {
					return val.replace(/\r/g, "" );
				}
				return val;
			},

			check: function( element ) {
				element = this.validationTargetFor( this.clean( element ) );

				var rules = $( element ).rules(),
					rulesCount = $.map( rules, function( n, i ) {
						return i;
					}).length,
					dependencyMismatch = false,
					val = this.elementValue( element ),
					result, method, rule;

				for ( method in rules ) {
					rule = { method: method, parameters: rules[ method ] };
					try {

						result = $.validator.methods[ method ].call( this, val, element, rule.parameters );

						// if a method indicates that the field is optional and therefore valid,
						// don't mark it as valid when there are no other rules
						if ( result === "dependency-mismatch" && rulesCount === 1 ) {
							dependencyMismatch = true;
							continue;
						}
						dependencyMismatch = false;

						if ( result === "pending" ) {
							this.toHide = this.toHide.not( this.errorsFor( element ) );
							return;
						}

						if ( !result ) {
							this.formatAndAdd( element, rule );
							return false;
						}
					} catch ( e ) {
						if ( this.settings.debug && window.console ) {
							console.log( "Exception occurred when checking element " + element.id + ", check the '" + rule.method + "' method.", e );
						}
						throw e;
					}
				}
				if ( dependencyMismatch ) {
					return;
				}
				if ( this.objectLength( rules ) ) {
					this.successList.push( element );
				}
				return true;
			},

			// return the custom message for the given element and validation method
			// specified in the element's HTML5 data attribute
			// return the generic message if present and no method specific message is present
			customDataMessage: function( element, method ) {
				return $( element ).data( "msg" + method.charAt( 0 ).toUpperCase() +
						method.substring( 1 ).toLowerCase() ) || $( element ).data( "msg" );
			},

			// return the custom message for the given element name and validation method
			customMessage: function( name, method ) {
				var m = this.settings.messages[ name ];
				return m && ( m.constructor === String ? m : m[ method ]);
			},

			// return the first defined argument, allowing empty strings
			findDefined: function() {
				for ( var i = 0; i < arguments.length; i++) {
					if ( arguments[ i ] !== undefined ) {
						return arguments[ i ];
					}
				}
				return undefined;
			},

			defaultMessage: function( element, method ) {
				return this.findDefined(
					this.customMessage( element.name, method ),
					this.customDataMessage( element, method ),
					// title is never undefined, so handle empty string as undefined
					!this.settings.ignoreTitle && element.title || undefined,
					$.validator.messages[ method ],
					"<strong>Warning: No message defined for " + element.name + "</strong>"
				);
			},

			formatAndAdd: function( element, rule ) {
				var message = this.defaultMessage( element, rule.method ),
					theregex = /\$?\{(\d+)\}/g;
				if ( typeof message === "function" ) {
					message = message.call( this, rule.parameters, element );
				} else if ( theregex.test( message ) ) {
					message = $.validator.format( message.replace( theregex, "{$1}" ), rule.parameters );
				}
				this.errorList.push({
					message: message,
					element: element,
					method: rule.method
				});

				this.errorMap[ element.name ] = message;
				this.submitted[ element.name ] = message;
			},

			addWrapper: function( toToggle ) {
				if ( this.settings.wrapper ) {
					toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
				}
				return toToggle;
			},

			defaultShowErrors: function() {
				var i, elements, error;
				for ( i = 0; this.errorList[ i ]; i++ ) {
					error = this.errorList[ i ];
					if ( this.settings.highlight ) {
						this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
					}
					this.showLabel( error.element, error.message );
				}
				if ( this.errorList.length ) {
					this.toShow = this.toShow.add( this.containers );
				}
				if ( this.settings.success ) {
					for ( i = 0; this.successList[ i ]; i++ ) {
						this.showLabel( this.successList[ i ] );
					}
				}
				if ( this.settings.unhighlight ) {
					for ( i = 0, elements = this.validElements(); elements[ i ]; i++ ) {
						this.settings.unhighlight.call( this, elements[ i ], this.settings.errorClass, this.settings.validClass );
					}
				}
				this.toHide = this.toHide.not( this.toShow );
				this.hideErrors();
				this.addWrapper( this.toShow ).show();
			},

			validElements: function() {
				return this.currentElements.not( this.invalidElements() );
			},

			invalidElements: function() {
				return $( this.errorList ).map(function() {
					return this.element;
				});
			},

			showLabel: function( element, message ) {
				var place, group, errorID,
					error = this.errorsFor( element ),
					elementID = this.idOrName( element ),
					describedBy = $( element ).attr( "aria-describedby" );
				if ( error.length ) {
					// refresh error/success class
					error.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );
					// replace message on existing label
					error.html( message );
				} else {
					// create error element
					error = $( "<" + this.settings.errorElement + ">" )
						.attr( "id", elementID + "-error" )
						.addClass( this.settings.errorClass )
						.html( message || "" );

					// Maintain reference to the element to be placed into the DOM
					place = error;
					if ( this.settings.wrapper ) {
						// make sure the element is visible, even in IE
						// actually showing the wrapped element is handled elsewhere
						place = error.hide().show().wrap( "<" + this.settings.wrapper + "/>" ).parent();
					}
					if ( this.labelContainer.length ) {
						this.labelContainer.append( place );
					} else if ( this.settings.errorPlacement ) {
						this.settings.errorPlacement( place, $( element ) );
					} else {
						place.insertAfter( element );
					}

					// Link error back to the element
					if ( error.is( "label" ) ) {
						// If the error is a label, then associate using 'for'
						error.attr( "for", elementID );
					} else if ( error.parents( "label[for='" + elementID + "']" ).length === 0 ) {
						// If the element is not a child of an associated label, then it's necessary
						// to explicitly apply aria-describedby

						errorID = error.attr( "id" ).replace( /(:|\.|\[|\])/g, "\\$1");
						// Respect existing non-error aria-describedby
						if ( !describedBy ) {
							describedBy = errorID;
						} else if ( !describedBy.match( new RegExp( "\\b" + errorID + "\\b" ) ) ) {
							// Add to end of list if not already present
							describedBy += " " + errorID;
						}
						$( element ).attr( "aria-describedby", describedBy );

						// If this element is grouped, then assign to all elements in the same group
						group = this.groups[ element.name ];
						if ( group ) {
							$.each( this.groups, function( name, testgroup ) {
								if ( testgroup === group ) {
									$( "[name='" + name + "']", this.currentForm )
										.attr( "aria-describedby", error.attr( "id" ) );
								}
							});
						}
					}
				}
				if ( !message && this.settings.success ) {
					error.text( "" );
					if ( typeof this.settings.success === "string" ) {
						error.addClass( this.settings.success );
					} else {
						this.settings.success( error, element );
					}
				}
				this.toShow = this.toShow.add( error );
			},

			errorsFor: function( element ) {
				var name = this.idOrName( element ),
					describer = $( element ).attr( "aria-describedby" ),
					selector = "label[for='" + name + "'], label[for='" + name + "'] *";

				// aria-describedby should directly reference the error element
				if ( describer ) {
					selector = selector + ", #" + describer.replace( /\s+/g, ", #" );
				}
				return this
					.errors()
					.filter( selector );
			},

			idOrName: function( element ) {
				return this.groups[ element.name ] || ( this.checkable( element ) ? element.name : element.id || element.name );
			},

			validationTargetFor: function( element ) {

				// If radio/checkbox, validate first element in group instead
				if ( this.checkable( element ) ) {
					element = this.findByName( element.name );
				}

				// Always apply ignore filter
				return $( element ).not( this.settings.ignore )[ 0 ];
			},

			checkable: function( element ) {
				return ( /radio|checkbox/i ).test( element.type );
			},

			findByName: function( name ) {
				return $( this.currentForm ).find( "[name='" + name + "']" );
			},

			getLength: function( value, element ) {
				switch ( element.nodeName.toLowerCase() ) {
					case "select":
						return $( "option:selected", element ).length;
					case "input":
						if ( this.checkable( element ) ) {
							return this.findByName( element.name ).filter( ":checked" ).length;
						}
				}
				return value.length;
			},

			depend: function( param, element ) {
				return this.dependTypes[typeof param] ? this.dependTypes[typeof param]( param, element ) : true;
			},

			dependTypes: {
				"boolean": function( param ) {
					return param;
				},
				"string": function( param, element ) {
					return !!$( param, element.form ).length;
				},
				"function": function( param, element ) {
					return param( element );
				}
			},

			optional: function( element ) {
				var val = this.elementValue( element );
				return !$.validator.methods.required.call( this, val, element ) && "dependency-mismatch";
			},

			startRequest: function( element ) {
				if ( !this.pending[ element.name ] ) {
					this.pendingRequest++;
					this.pending[ element.name ] = true;
				}
			},

			stopRequest: function( element, valid ) {
				this.pendingRequest--;
				// sometimes synchronization fails, make sure pendingRequest is never < 0
				if ( this.pendingRequest < 0 ) {
					this.pendingRequest = 0;
				}
				delete this.pending[ element.name ];
				if ( valid && this.pendingRequest === 0 && this.formSubmitted && this.form() ) {
					$( this.currentForm ).submit();
					this.formSubmitted = false;
				} else if (!valid && this.pendingRequest === 0 && this.formSubmitted ) {
					$( this.currentForm ).triggerHandler( "invalid-form", [ this ]);
					this.formSubmitted = false;
				}
			},

			previousValue: function( element ) {
				return $.data( element, "previousValue" ) || $.data( element, "previousValue", {
						old: null,
						valid: true,
						message: this.defaultMessage( element, "remote" )
					});
			}

		},

		classRuleSettings: {
			required: { required: true },
			email: { email: true },
			url: { url: true },
			date: { date: true },
			dateISO: { dateISO: true },
			number: { number: true },
			digits: { digits: true },
			creditcard: { creditcard: true }
		},

		addClassRules: function( className, rules ) {
			if ( className.constructor === String ) {
				this.classRuleSettings[ className ] = rules;
			} else {
				$.extend( this.classRuleSettings, className );
			}
		},

		classRules: function( element ) {
			var rules = {},
				classes = $( element ).attr( "class" );

			if ( classes ) {
				$.each( classes.split( " " ), function() {
					if ( this in $.validator.classRuleSettings ) {
						$.extend( rules, $.validator.classRuleSettings[ this ]);
					}
				});
			}
			return rules;
		},

		attributeRules: function( element ) {
			var rules = {},
				$element = $( element ),
				type = element.getAttribute( "type" ),
				method, value;

			for ( method in $.validator.methods ) {

				// support for <input required> in both html5 and older browsers
				if ( method === "required" ) {
					value = element.getAttribute( method );
					// Some browsers return an empty string for the required attribute
					// and non-HTML5 browsers might have required="" markup
					if ( value === "" ) {
						value = true;
					}
					// force non-HTML5 browsers to return bool
					value = !!value;
				} else {
					value = $element.attr( method );
				}

				// convert the value to a number for number inputs, and for text for backwards compability
				// allows type="date" and others to be compared as strings
				if ( /min|max/.test( method ) && ( type === null || /number|range|text/.test( type ) ) ) {
					value = Number( value );
				}

				if ( value || value === 0 ) {
					rules[ method ] = value;
				} else if ( type === method && type !== "range" ) {
					// exception: the jquery validate 'range' method
					// does not test for the html5 'range' type
					rules[ method ] = true;
				}
			}

			// maxlength may be returned as -1, 2147483647 ( IE ) and 524288 ( safari ) for text inputs
			if ( rules.maxlength && /-1|2147483647|524288/.test( rules.maxlength ) ) {
				delete rules.maxlength;
			}

			return rules;
		},

		dataRules: function( element ) {
			var method, value,
				rules = {}, $element = $( element );
			for ( method in $.validator.methods ) {
				value = $element.data( "rule" + method.charAt( 0 ).toUpperCase() + method.substring( 1 ).toLowerCase() );
				if ( value !== undefined ) {
					rules[ method ] = value;
				}
			}
			return rules;
		},

		staticRules: function( element ) {
			var rules = {},
				validator = $.data( element.form, "validator" );

			if ( validator.settings.rules ) {
				rules = $.validator.normalizeRule( validator.settings.rules[ element.name ] ) || {};
			}
			return rules;
		},

		normalizeRules: function( rules, element ) {
			// handle dependency check
			$.each( rules, function( prop, val ) {
				// ignore rule when param is explicitly false, eg. required:false
				if ( val === false ) {
					delete rules[ prop ];
					return;
				}
				if ( val.param || val.depends ) {
					var keepRule = true;
					switch ( typeof val.depends ) {
						case "string":
							keepRule = !!$( val.depends, element.form ).length;
							break;
						case "function":
							keepRule = val.depends.call( element, element );
							break;
					}
					if ( keepRule ) {
						rules[ prop ] = val.param !== undefined ? val.param : true;
					} else {
						delete rules[ prop ];
					}
				}
			});

			// evaluate parameters
			$.each( rules, function( rule, parameter ) {
				rules[ rule ] = $.isFunction( parameter ) ? parameter( element ) : parameter;
			});

			// clean number parameters
			$.each([ "minlength", "maxlength" ], function() {
				if ( rules[ this ] ) {
					rules[ this ] = Number( rules[ this ] );
				}
			});
			$.each([ "rangelength", "range" ], function() {
				var parts;
				if ( rules[ this ] ) {
					if ( $.isArray( rules[ this ] ) ) {
						rules[ this ] = [ Number( rules[ this ][ 0 ]), Number( rules[ this ][ 1 ] ) ];
					} else if ( typeof rules[ this ] === "string" ) {
						parts = rules[ this ].replace(/[\[\]]/g, "" ).split( /[\s,]+/ );
						rules[ this ] = [ Number( parts[ 0 ]), Number( parts[ 1 ] ) ];
					}
				}
			});

			if ( $.validator.autoCreateRanges ) {
				// auto-create ranges
				if ( rules.min != null && rules.max != null ) {
					rules.range = [ rules.min, rules.max ];
					delete rules.min;
					delete rules.max;
				}
				if ( rules.minlength != null && rules.maxlength != null ) {
					rules.rangelength = [ rules.minlength, rules.maxlength ];
					delete rules.minlength;
					delete rules.maxlength;
				}
			}

			return rules;
		},

		// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
		normalizeRule: function( data ) {
			if ( typeof data === "string" ) {
				var transformed = {};
				$.each( data.split( /\s/ ), function() {
					transformed[ this ] = true;
				});
				data = transformed;
			}
			return data;
		},

		// http://jqueryvalidation.org/jQuery.validator.addMethod/
		addMethod: function( name, method, message ) {
			$.validator.methods[ name ] = method;
			$.validator.messages[ name ] = message !== undefined ? message : $.validator.messages[ name ];
			if ( method.length < 3 ) {
				$.validator.addClassRules( name, $.validator.normalizeRule( name ) );
			}
		},

		methods: {

			// http://jqueryvalidation.org/required-method/
			required: function( value, element, param ) {
				// check if dependency is met
				if ( !this.depend( param, element ) ) {
					return "dependency-mismatch";
				}
				if ( element.nodeName.toLowerCase() === "select" ) {
					// could be an array for select-multiple or a string, both are fine this way
					var val = $( element ).val();
					return val && val.length > 0;
				}
				if ( this.checkable( element ) ) {
					return this.getLength( value, element ) > 0;
				}
				return $.trim( value ).length > 0;
			},

			// http://jqueryvalidation.org/email-method/
			email: function( value, element ) {
				// From http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#e-mail-state-%28type=email%29
				// Retrieved 2014-01-14
				// If you have a problem with this implementation, report a bug against the above spec
				// Or use custom methods to implement your own email validation
				return this.optional( element ) || /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/.test( value );
			},

			// http://jqueryvalidation.org/url-method/
			url: function( value, element ) {
				// contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
				return this.optional( element ) || /^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
			},

			// http://jqueryvalidation.org/date-method/
			date: function( value, element ) {
				return this.optional( element ) || !/Invalid|NaN/.test( new Date( value ).toString() );
			},

			// http://jqueryvalidation.org/dateISO-method/
			dateISO: function( value, element ) {
				return this.optional( element ) || /^\d{4}[\/\-](0?[1-9]|1[012])[\/\-](0?[1-9]|[12][0-9]|3[01])$/.test( value );
			},

			// http://jqueryvalidation.org/number-method/
			number: function( value, element ) {
				return this.optional( element ) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test( value );
			},

			// http://jqueryvalidation.org/digits-method/
			digits: function( value, element ) {
				return this.optional( element ) || /^\d+$/.test( value );
			},

			// http://jqueryvalidation.org/creditcard-method/
			// based on http://en.wikipedia.org/wiki/Luhn/
			creditcard: function( value, element ) {
				if ( this.optional( element ) ) {
					return "dependency-mismatch";
				}
				// accept only spaces, digits and dashes
				if ( /[^0-9 \-]+/.test( value ) ) {
					return false;
				}
				var nCheck = 0,
					nDigit = 0,
					bEven = false,
					n, cDigit;

				value = value.replace( /\D/g, "" );

				// Basing min and max length on
				// http://developer.ean.com/general_info/Valid_Credit_Card_Types
				if ( value.length < 13 || value.length > 19 ) {
					return false;
				}

				for ( n = value.length - 1; n >= 0; n--) {
					cDigit = value.charAt( n );
					nDigit = parseInt( cDigit, 10 );
					if ( bEven ) {
						if ( ( nDigit *= 2 ) > 9 ) {
							nDigit -= 9;
						}
					}
					nCheck += nDigit;
					bEven = !bEven;
				}

				return ( nCheck % 10 ) === 0;
			},

			// http://jqueryvalidation.org/minlength-method/
			minlength: function( value, element, param ) {
				var length = $.isArray( value ) ? value.length : this.getLength( value, element );
				return this.optional( element ) || length >= param;
			},

			// http://jqueryvalidation.org/maxlength-method/
			maxlength: function( value, element, param ) {
				var length = $.isArray( value ) ? value.length : this.getLength( value, element );
				return this.optional( element ) || length <= param;
			},

			// http://jqueryvalidation.org/rangelength-method/
			rangelength: function( value, element, param ) {
				var length = $.isArray( value ) ? value.length : this.getLength( value, element );
				return this.optional( element ) || ( length >= param[ 0 ] && length <= param[ 1 ] );
			},

			// http://jqueryvalidation.org/min-method/
			min: function( value, element, param ) {
				return this.optional( element ) || value >= param;
			},

			// http://jqueryvalidation.org/max-method/
			max: function( value, element, param ) {
				return this.optional( element ) || value <= param;
			},

			// http://jqueryvalidation.org/range-method/
			range: function( value, element, param ) {
				return this.optional( element ) || ( value >= param[ 0 ] && value <= param[ 1 ] );
			},

			// http://jqueryvalidation.org/equalTo-method/
			equalTo: function( value, element, param ) {
				// bind to the blur event of the target in order to revalidate whenever the target field is updated
				// TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
				var target = $( param );
				if ( this.settings.onfocusout ) {
					target.unbind( ".validate-equalTo" ).bind( "blur.validate-equalTo", function() {
						$( element ).valid();
					});
				}
				return value === target.val();
			},

			// http://jqueryvalidation.org/remote-method/
			remote: function( value, element, param ) {
				if ( this.optional( element ) ) {
					return "dependency-mismatch";
				}

				var previous = this.previousValue( element ),
					validator, data;

				if (!this.settings.messages[ element.name ] ) {
					this.settings.messages[ element.name ] = {};
				}
				previous.originalMessage = this.settings.messages[ element.name ].remote;
				this.settings.messages[ element.name ].remote = previous.message;

				param = typeof param === "string" && { url: param } || param;

				if ( previous.old === value ) {
					return previous.valid;
				}

				previous.old = value;
				validator = this;
				this.startRequest( element );
				data = {};
				data[ element.name ] = value;
				$.ajax( $.extend( true, {
					url: param,
					mode: "abort",
					port: "validate" + element.name,
					dataType: "json",
					data: data,
					context: validator.currentForm,
					success: function( response ) {
						var valid = response === true || response === "true",
							errors, message, submitted;

						validator.settings.messages[ element.name ].remote = previous.originalMessage;
						if ( valid ) {
							submitted = validator.formSubmitted;
							validator.prepareElement( element );
							validator.formSubmitted = submitted;
							validator.successList.push( element );
							delete validator.invalid[ element.name ];
							validator.showErrors();
						} else {
							errors = {};
							message = response || validator.defaultMessage( element, "remote" );
							errors[ element.name ] = previous.message = $.isFunction( message ) ? message( value ) : message;
							validator.invalid[ element.name ] = true;
							validator.showErrors( errors );
						}
						previous.valid = valid;
						validator.stopRequest( element, valid );
					}
				}, param ) );
				return "pending";
			}

		}

	});

	$.format = function deprecated() {
		throw "$.format has been deprecated. Please use $.validator.format instead.";
	};

// ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()

	var pendingRequests = {},
		ajax;
// Use a prefilter if available (1.5+)
	if ( $.ajaxPrefilter ) {
		$.ajaxPrefilter(function( settings, _, xhr ) {
			var port = settings.port;
			if ( settings.mode === "abort" ) {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = xhr;
			}
		});
	} else {
		// Proxy ajax
		ajax = $.ajax;
		$.ajax = function( settings ) {
			var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
				port = ( "port" in settings ? settings : $.ajaxSettings ).port;
			if ( mode === "abort" ) {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = ajax.apply(this, arguments);
				return pendingRequests[port];
			}
			return ajax.apply(this, arguments);
		};
	}

// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target

	$.extend($.fn, {
		validateDelegate: function( delegate, type, handler ) {
			return this.bind(type, function( event ) {
				var target = $(event.target);
				if ( target.is(delegate) ) {
					return handler.apply(target, arguments);
				}
			});
		}
	});

}));
function strlen(string) {
	//  discuss at: http://phpjs.org/functions/strlen/
	// original by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// improved by: Sakimori
	// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	//    input by: Kirk Strobeck
	// bugfixed by: Onno Marsman
	//  revised by: Brett Zamir (http://brett-zamir.me)
	//        note: May look like overkill, but in order to be truly faithful to handling all Unicode
	//        note: characters and to this function in PHP which does not count the number of bytes
	//        note: but counts the number of characters, something like this is really necessary.
	//   example 1: strlen('Kevin van Zonneveld');
	//   returns 1: 19
	//   example 2: ini_set('unicode.semantics', 'on');
	//   example 2: strlen('A\ud87e\udc04Z');
	//   returns 2: 3

	var str = string + '';
	var i = 0,
		chr = '',
		lgth = 0;

	if (!this.php_js || !this.php_js.ini || !this.php_js.ini['unicode.semantics'] || this.php_js.ini[
			'unicode.semantics'].local_value.toLowerCase() !== 'on') {
		return string.length;
	}

	var getWholeChar = function (str, i) {
		var code = str.charCodeAt(i);
		var next = '',
			prev = '';
		if (0xD800 <= code && code <= 0xDBFF) {
			// High surrogate (could change last hex to 0xDB7F to treat high private surrogates as single characters)
			if (str.length <= (i + 1)) {
				throw 'High surrogate without following low surrogate';
			}
			next = str.charCodeAt(i + 1);
			if (0xDC00 > next || next > 0xDFFF) {
				throw 'High surrogate without following low surrogate';
			}
			return str.charAt(i) + str.charAt(i + 1);
		} else if (0xDC00 <= code && code <= 0xDFFF) {
			// Low surrogate
			if (i === 0) {
				throw 'Low surrogate without preceding high surrogate';
			}
			prev = str.charCodeAt(i - 1);
			if (0xD800 > prev || prev > 0xDBFF) {
				//(could change last hex to 0xDB7F to treat high private surrogates as single characters)
				throw 'Low surrogate without preceding high surrogate';
			}
			// We can pass over low surrogates now as the second component in a pair which we have already processed
			return false;
		}
		return str.charAt(i);
	};

	for (i = 0, lgth = 0; i < str.length; i++) {
		if ((chr = getWholeChar(str, i)) === false) {
			continue;
		} // Adapt this line at the top of any loop, passing in the whole string and the current iteration and returning a variable to represent the individual character; purpose is to treat the first part of a surrogate pair as the whole character and then ignore the second part
		lgth++;
	}
	return lgth;
}
function strtotime(text, now) {
	//  discuss at: http://phpjs.org/functions/strtotime/
	//     version: 1109.2016
	// original by: Caio Ariede (http://caioariede.com)
	// improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)
	// improved by: Caio Ariede (http://caioariede.com)
	// improved by: A. MatÃ­as Quezada (http://amatiasq.com)
	// improved by: preuter
	// improved by: Brett Zamir (http://brett-zamir.me)
	// improved by: Mirko Faber
	//    input by: David
	// bugfixed by: Wagner B. Soares
	// bugfixed by: Artur Tchernychev
	//        note: Examples all have a fixed timestamp to prevent tests to fail because of variable time(zones)
	//   example 1: strtotime('+1 day', 1129633200);
	//   returns 1: 1129719600
	//   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200);
	//   returns 2: 1130425202
	//   example 3: strtotime('last month', 1129633200);
	//   returns 3: 1127041200
	//   example 4: strtotime('2009-05-04 08:30:00 GMT');
	//   returns 4: 1241425800

	var parsed, match, today, year, date, days, ranges, len, times, regex, i, fail = false;

	if (!text) {
		return fail;
	}

	// Unecessary spaces
	text = text.replace(/^\s+|\s+$/g, '')
		.replace(/\s{2,}/g, ' ')
		.replace(/[\t\r\n]/g, '')
		.toLowerCase();

	// in contrast to php, js Date.parse function interprets:
	// dates given as yyyy-mm-dd as in timezone: UTC,
	// dates with "." or "-" as MDY instead of DMY
	// dates with two-digit years differently
	// etc...etc...
	// ...therefore we manually parse lots of common date formats
	match = text.match(
		/^(\d{1,4})([\-\.\/\:])(\d{1,2})([\-\.\/\:])(\d{1,4})(?:\s(\d{1,2}):(\d{2})?:?(\d{2})?)?(?:\s([A-Z]+)?)?$/);

	if (match && match[2] === match[4]) {
		if (match[1] > 1901) {
			switch (match[2]) {
				case '-':
				{
					// YYYY-M-D
					if (match[3] > 12 || match[5] > 31) {
						return fail;
					}

					return new Date(match[1], parseInt(match[3], 10) - 1, match[5],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
				case '.':
				{
					// YYYY.M.D is not parsed by strtotime()
					return fail;
				}
				case '/':
				{
					// YYYY/M/D
					if (match[3] > 12 || match[5] > 31) {
						return fail;
					}

					return new Date(match[1], parseInt(match[3], 10) - 1, match[5],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
			}
		} else if (match[5] > 1901) {
			switch (match[2]) {
				case '-':
				{
					// D-M-YYYY
					if (match[3] > 12 || match[1] > 31) {
						return fail;
					}

					return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
				case '.':
				{
					// D.M.YYYY
					if (match[3] > 12 || match[1] > 31) {
						return fail;
					}

					return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
				case '/':
				{
					// M/D/YYYY
					if (match[1] > 12 || match[3] > 31) {
						return fail;
					}

					return new Date(match[5], parseInt(match[1], 10) - 1, match[3],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
			}
		} else {
			switch (match[2]) {
				case '-':
				{
					// YY-M-D
					if (match[3] > 12 || match[5] > 31 || (match[1] < 70 && match[1] > 38)) {
						return fail;
					}

					year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1];
					return new Date(year, parseInt(match[3], 10) - 1, match[5],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
				case '.':
				{
					// D.M.YY or H.MM.SS
					if (match[5] >= 70) {
						// D.M.YY
						if (match[3] > 12 || match[1] > 31) {
							return fail;
						}

						return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
								match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
					}
					if (match[5] < 60 && !match[6]) {
						// H.MM.SS
						if (match[1] > 23 || match[3] > 59) {
							return fail;
						}

						today = new Date();
						return new Date(today.getFullYear(), today.getMonth(), today.getDate(),
								match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000;
					}

					// invalid format, cannot be parsed
					return fail;
				}
				case '/':
				{
					// M/D/YY
					if (match[1] > 12 || match[3] > 31 || (match[5] < 70 && match[5] > 38)) {
						return fail;
					}

					year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5];
					return new Date(year, parseInt(match[1], 10) - 1, match[3],
							match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000;
				}
				case ':':
				{
					// HH:MM:SS
					if (match[1] > 23 || match[3] > 59 || match[5] > 59) {
						return fail;
					}

					today = new Date();
					return new Date(today.getFullYear(), today.getMonth(), today.getDate(),
							match[1] || 0, match[3] || 0, match[5] || 0) / 1000;
				}
			}
		}
	}

	// other formats and "now" should be parsed by Date.parse()
	if (text === 'now') {
		return now === null || isNaN(now) ? new Date()
			.getTime() / 1000 | 0 : now | 0;
	}
	if (!isNaN(parsed = Date.parse(text))) {
		return parsed / 1000 | 0;
	}

	date = now ? new Date(now * 1000) : new Date();
	days = {
		'sun': 0,
		'mon': 1,
		'tue': 2,
		'wed': 3,
		'thu': 4,
		'fri': 5,
		'sat': 6
	};
	ranges = {
		'yea': 'FullYear',
		'mon': 'Month',
		'day': 'Date',
		'hou': 'Hours',
		'min': 'Minutes',
		'sec': 'Seconds'
	};

	function lastNext(type, range, modifier) {
		var diff, day = days[range];

		if (typeof day !== 'undefined') {
			diff = day - date.getDay();

			if (diff === 0) {
				diff = 7 * modifier;
			} else if (diff > 0 && type === 'last') {
				diff -= 7;
			} else if (diff < 0 && type === 'next') {
				diff += 7;
			}

			date.setDate(date.getDate() + diff);
		}
	}

	function process(val) {
		var splt = val.split(' '), // Todo: Reconcile this with regex using \s, taking into account browser issues with split and regexes
			type = splt[0],
			range = splt[1].substring(0, 3),
			typeIsNumber = /\d+/.test(type),
			ago = splt[2] === 'ago',
			num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1);

		if (typeIsNumber) {
			num *= parseInt(type, 10);
		}

		if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\.)?$/i)) {
			return date['set' + ranges[range]](date['get' + ranges[range]]() + num);
		}

		if (range === 'wee') {
			return date.setDate(date.getDate() + (num * 7));
		}

		if (type === 'next' || type === 'last') {
			lastNext(type, range, num);
		} else if (!typeIsNumber) {
			return false;
		}

		return true;
	}

	times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' +
		'|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?' +
		'|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)';
	regex = '([+-]?\\d+\\s' + times + '|' + '(last|next)\\s' + times + ')(\\sago)?';

	match = text.match(new RegExp(regex, 'gi'));
	if (!match) {
		return fail;
	}

	for (i = 0, len = match.length; i < len; i++) {
		if (!process(match[i])) {
			return fail;
		}
	}

	// ECMAScript 5 only
	// if (!match.every(process))
	//    return false;

	return (date.getTime() / 1000);
}
/*!
 * @copyright Copyright &copy; Kartik Visweswaran, Krajee.com, 2014
 * @version 1.3.0
 *
 * Date formatter utility library, that allows you to format date and 
 * time variables or Date objects using PHP DateTime format.
 * @see http://php.net/manual/en/function.date.php
 * 
 * Authors:
 *      [Kartik Visweswaran](https://github.com/kartik-v)
 *      [Enrica R](https://github.com/Erik-r)
 *
 * For more JQuery plugins visit http://plugins.krajee.com
 * For more Yii related demos visit http://demos.krajee.com
 */
var defaultConfig = {
	dateSettings: {
		days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
		daysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
		months: ['January', 'February', 'March', 'April', 'May', 'June',
			'July', 'August', 'September', 'October', 'November', 'December'],
		monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
		meridiem: ['AM', 'PM']
	},
	separators: /[ \-+\/\.T:@]/g,
	validParts: /[djDlwSFmMnyYaAgGhHisU]/g
};

var DateFormatter = function (options) {
	var config = $.extend(true, defaultConfig, options);
	this.dateSettings = config.dateSettings;
	this.separators = config.separators;
	this.validParts = config.validParts;
};

DateFormatter.prototype = {
	constructor: DateFormatter,
	parseDate: function (vDate, vFormat) {
		if (!vDate) {
			return undefined;
		}
		if (vDate instanceof Date) {
			return vDate;
		}
		if (typeof vDate == 'number') {
			return new Date(vDate);
		}
		var self = this,
			parsedDateTime = {
				date: null,
				year: null,
				month: null,
				day: null,
				dayOfWeek: null,
				hour: 0,
				min: 0,
				sec: 0
			};

		if (vDate instanceof Date) {
			return vDate;
		} else if (typeof vDate == 'string') {
			var vFormatParts = vFormat.match(self.validParts);
			if (!vFormatParts || vFormatParts.length === 0) {
				throw new Error("Invalid date format definition.");
			}
			var vDateParts = vDate.replace(self.separators, '\0').split('\0');
			var i, vDateFlag = false , vTimeFlag = false;
			for (i = 0; i < vDateParts.length; i++) {
				switch (vFormatParts[i]) {
					case 'y':
					case 'Y':
						if (vDateParts[i].length == 2) {
							parsedDateTime.year = parseInt(((parseInt(vDateParts[i]) < 70) ? '20' : '19') + vDateParts[i]);
						} else if (vDateParts[i].length == 4) {
							parsedDateTime.year = parseInt(vDateParts[i]);
						}
						vDateFlag = true;
						break;
					case 'm':
					case 'n':
					case 'M':
					case 'F':
						var vMonth;
						if (isNaN(vDateParts[i])) {
							vMonth = self.dateSettings.monthsShort.indexOf(vDateParts[i]);
							if (vMonth > -1) {
								parsedDateTime.month = vMonth + 1;
							}
							vMonth = self.dateSettings.months.indexOf(vDateParts[i]);
							if (vMonth > -1) {
								parsedDateTime.month = vMonth + 1;
							}
						} else {
							if (parseInt(vDateParts[i]) >= 1 && parseInt(vDateParts[i]) <= 12) {
								parsedDateTime.month = parseInt(vDateParts[i]);
							}
						}
						vDateFlag = true;
						break;
					case 'd':
					case 'j':
						if (parseInt(vDateParts[i]) >= 1 && parseInt(vDateParts[i]) <= 31) {
							parsedDateTime.day = parseInt(vDateParts[i]);
						}
						vDateFlag = true;
						break;
					case 'g':
					case 'h':
						var vMeriIndex = (vFormatParts.indexOf('a') > -1) ? vFormatParts.indexOf('a') :
							(vFormatParts.indexOf('A') > -1) ? vFormatParts.indexOf('A') : -1;

						if (vMeriIndex > -1) {
							var vMeriOffset = (vDateParts[vMeriIndex].toLowerCase == self.dateSettings.meridiem[0].toLowerCase) ? 0 :
								(vDateParts[vMeriIndex].toLowerCase == self.dateSettings.meridiem[1].toLowerCase) ? 12 : -1;

							if (parseInt(vDateParts[i]) >= 1 && parseInt(vDateParts[i]) <= 12 && vMeriOffset > -1) {
								parsedDateTime.hour = parseInt(vDateParts[i]) + vMeriOffset - 1;
							} else if (parseInt(vDateParts[i]) >= 0 && parseInt(vDateParts[i]) <= 23) {
								parsedDateTime.hour = parseInt(vDateParts[i]);
							}
						} else if (parseInt(vDateParts[i]) >= 0 && parseInt(vDateParts[i]) <= 23) {
							parsedDateTime.hour = parseInt(vDateParts[i]);
						}
						vTimeFlag = true;
						break;
					case 'G':
					case 'H':
						if (parseInt(vDateParts[i]) >= 0 && parseInt(vDateParts[i]) <= 23) {
							parsedDateTime.hour = parseInt(vDateParts[i]);
						}
						vTimeFlag = true;
						break;
					case 'i':
						if (parseInt(vDateParts[i]) >= 0 && parseInt(vDateParts[i]) <= 59) {
							parsedDateTime.min = parseInt(vDateParts[i]);
						}
						vTimeFlag = true;
						break;
					case 's':
						if (parseInt(vDateParts[i]) >= 0 && parseInt(vDateParts[i]) <= 59) {
							parsedDateTime.sec = parseInt(vDateParts[i]);
						}
						vTimeFlag = true;
				}
			}
			if (vDateFlag === true && parsedDateTime.year && parsedDateTime.month && parsedDateTime.day) {
				parsedDateTime.date = new Date(parsedDateTime.year, parsedDateTime.month - 1, parsedDateTime.day, parsedDateTime.hour, parsedDateTime.min, parsedDateTime.sec, 0);
				// parsedDateTime.dayOfWeek = parsedDateTime.date.getDay();
				return parsedDateTime.date;
			} else if (vTimeFlag === true) {
				parsedDateTime.date = new Date(0, 0, 0, parsedDateTime.hour, parsedDateTime.min, parsedDateTime.sec, 0);
				return parsedDateTime.date;
			} else {
				return false;
			}
		}
	},
	guessDate: function (vDateStr, vFormat) {
		var self = this;
		if (typeof vDateStr != 'string') {
			return vDateStr;
		}

		var vParts = vDateStr.replace(self.separators, '\0').split('\0'),
			vFormatParts = vFormat.match(self.validParts),
			vPattern = /^[djmn]/g;

		if (vPattern.test(vFormatParts[0])) {

			var vDate = new Date(),
				vDigit = 0, i;

			for (i = 0; i < vParts.length; i++) {
				vDigit = 2;
				switch (i) {
					case 0:
						if (vFormatParts[0] == 'm' || vFormatParts[0] == 'n') {
							vDate.setMonth(parseInt(vParts[i].substr(0, 2)) - 1);
						} else {
							vDate.setDate(parseInt(vParts[i].substr(0, 2)));
						}
						break;
					case 1:
						if (vFormatParts[0] == 'm' || vFormatParts[0] == 'n') {
							vDate.setDate(parseInt(vParts[i].substr(0, 2)));

						} else {
							vDate.setMonth(parseInt(vParts[i].substr(0, 2)) - 1);
						}
						break;
					case 2:
						var year = vDate.getFullYear();

						if (vParts[i].length < 4) {
							vDate.setFullYear(parseInt(year.toString().substr(0, 4 - vParts[i].length) + vParts[i]));
							vDigit = vParts[i].length;
						} else {
							vDate.setFullYear = parseInt(vParts[i].substr(0, 4));
							vDigit = 4;
						}
						break;
					case 3:
						vDate.setHours(parseInt(vParts[i].substr(0, 2)));
						break;
					case 4:
						vDate.setMinutes(parseInt(vParts[i].substr(0, 2)));
						break;
					case 5:
						vDate.setSeconds(parseInt(vParts[i].substr(0, 2)));
				}
				if (vParts[i].substr(vDigit).length > 0) {
					vParts.splice(i + 1, 0, vParts[i].substr(vDigit));
				}
			}
			return vDate;
		}
	},
	formatDate: function (vDate, vFormat) {
		var self = this;
		if (typeof vDate == 'string') {
			vDate = self.parseDate(vDate, vFormat);
			if (vDate == false) {
				return false;
			}
		}
		if (vDate instanceof Date) {
			var i, vChar, vDateStr = '', self = this;
			var validParts = /[djDlwSFmMnyYaAgGhHisU]/;
			for (i = 0; i < vFormat.length; i++) {
				vChar = vFormat.charAt(i);
				if (validParts.test(vChar) == true) {
					switch (vChar) {
						case 'j':
							vDateStr += vDate.getDate();
							break;
						case 'd':
							vDateStr += ((vDate.getDate() <= 9) ? '0' : '') + vDate.getDate();
							break;
						case 'D':
							vDateStr += self.dateSettings.daysShort[vDate.getDay()];
							break;
						case 'l':
							vDateStr += self.dateSettings.days[vDate.getDay()];
							break;
						case 'w':
							vDateStr += vDate.getDay();
							break;
						case 'S':
							var vDay = vDate.getDay();
							if (vDay == 1 || vDay == 21 || vDay == 31) {
								vDateStr += 'st';
							} else if (vDay == 2 || vDay == 22) {
								vDateStr += 'nd';
							} else if (vDay == 3 || vDay == 23) {
								vDateStr += 'rd';
							} else {
								vDateStr += 'th';
							}
							break;
						case 'n':
							vDateStr += vDate.getMonth() + 1;
							break;
						case 'm':
							vDateStr += ((vDate.getMonth() <= 8) ? '0' : '') + (vDate.getMonth() + 1);
							break;
						case 'F':
							vDateStr += self.dateSettings.months[vDate.getMonth()];
							break;
						case 'M':
							vDateStr += self.dateSettings.monthsShort[vDate.getMonth()];
							break;
						case 'Y':
							vDateStr += vDate.getFullYear();
							break;
						case 'y':
							vDateStr += vDate.getFullYear().substr(2);
							break;
						case 'g':
							vDateStr += (vDate.getHours() % 12) + 1;
							break;
						case 'G':
							vDateStr += vDate.getHours();
							break;
						case 'h':
							vDateStr += ((vDate.getHours() % 12 <= 8) ? '0' : '') + ((vDate.getHours() % 12) + 1);
							break;
						case 'H':
							vDateStr += ((vDate.getHours() <= 9) ? '0' : '') + vDate.getHours();
							break;
						case 'a':
						case 'A':
							vDateStr += (vDate.getHours <= 12) ? self.dateSettings.meridiem[0] : self.dateSettings.meridiem[1];
							break;
						case 'i':
							vDateStr += ((vDate.getMinutes() <= 9) ? '0' : '') + vDate.getMinutes();
							break;
						case 's':
							vDateStr += ((vDate.getSeconds() <= 9) ? '0' : '') + vDate.getSeconds();
							break;
						case 'U':
							vDateStr += vDate.getMilliseconds() / 1000;
							break;
					}

				} else {
					vDateStr += vChar;
				}
			}
			return vDateStr;
		}
	}
};
/*!
 * Laravel Javascript Validation
 *
 * https://github.com/proengsoft/laravel-jsvalidation
 *
 * Copyright (c) 2014 Proengsoft
 * Released under the MIT license
 */

var laravelValidation  = {

	/**
	 * Initialize laravel validations
	 */
	init: function() {
		this.methods();
	}

};

$(function() {
	laravelValidation.init();
});
/*!
 * Laravel Javascript Validation
 *
 * https://github.com/proengsoft/laravel-jsvalidation
 *
 * Helper functions used by validators
 *
 * Copyright (c) 2014 Proengsoft
 * Released under the MIT license
 */

$.extend(true, laravelValidation, {

	helpers: {

		/**
		 * Gets the file information from file input
		 *
		 * @param fieldObj
		 * @returns {{file: *, extension: string, size: number}}
		 */
		fileinfo: function (fieldObj) {
			var FileName = fieldObj.value;
			return {
				file: FileName,
				extension: FileName.substr(FileName.lastIndexOf('.') + 1),
				size: fieldObj.files[0].size / 1024
			};
		},


		/**
		 *
		 * Gets the selectors for th specified field names
		 *
		 * @param names
		 * @returns {string}
		 */
		selector: function (names) {
			var selector = [];
			if (!$.isArray(names)) names = [names];
			for (var i = 0; i < names.length; i++) {
				selector.push("[name='" + names[i] + "']");
			}
			return selector.join();
		},


		/**
		 * Gets the specified form element
		 *
		 * @param element
		 * @param name
		 * @returns {*}
		 */
		getElement: function getElement(element, name) {

			var $form = $(element).closest('form');
			var elementCache = {};

			var $el = $form
				.find(this.selector(name))
				// .find( "input"+selectorName+", select"+selectorName+", textarea"+selectorName )
				.not(":submit, :reset, :image, [readonly]")
				.filter(function () {
					// select only the first element for each name
					if (this.name in elementCache) {
						return false;
					}
					elementCache[this.name] = true;
					return true;
				});
			// / If check element not found, return false
			if ($el == '' || $el == 'undefined' || $el.length == 0) {
				return false;
			}
			return $el;
		},


		/**
		 * Check if element has numeric rules
		 *
		 * @param element
		 * @returns {boolean}
		 */
		hasNumericRules: function (element) {

			var numericRules = ['laravelNumeric', 'laravelInteger'];
			var found = false;

			var validator = $.data(element.form, "validator");
			var objRules = validator.settings.rules[element.name];

			for (var i = 0; i < numericRules.length; i++) {
				found = found || numericRules[i] in objRules;
			}

			return found;
		},


		/**
		 * Return the string length using PHP function
		 * http://php.net/manual/en/function.strlen.php
		 * http://phpjs.org/functions/strlen/
		 *
		 * @param string
		 */
		strlen: function (string) {
			return strlen(string);
		},


		/**
		 * Get the size of the object depending of his type
		 *
		 * @param obj
		 * @param element
		 * @param value
		 * @returns int
		 */
		getSize: function getSize(obj, element, value) {

			if (this.hasNumericRules(element) && /^-?(?:\d+|\d{1,3}(?:,\d{3})+)?(?:\.\d+)?$/.test(value)) {
				return value;
			} else if ($.isArray(value)) {
				return value.length;
			} else if (element.type == 'file') {
				return this.fileinfo(element).size;
			}

			return this.strlen(value);
		},


		/**
		 * Return he timestamp of value passed using format or default format in element*
		 *
		 * @param value
		 * @param format
		 * @returns {boolean|int}
		 */
		parseTime: function (value, format) {

			var timeValue = false;
			var fmt = new DateFormatter();

			if ($.type(format) == 'object') {
				if ('laravelDateFormat' in $.validator.staticRules(format)) {
					format = $.validator.staticRules(format).laravelDateFormat[0];
				} else {
					format = null;
				}
			}

			if (format == null) {
				timeValue = this.strtotime(value);
			} else {
				timeValue = fmt.parseDate(value, format);
				if (timeValue) {
					timeValue = Math.round((timeValue.getTime() / 1000));
				}
			}

			return timeValue;
		},


		/**
		 * Returns Unix timestamp based on PHP function strototime
		 * http://php.net/manual/es/function.strtotime.php
		 * http://phpjs.org/functions/strtotime/
		 *
		 * @param text
		 * @param now
		 * @returns {*}
		 */
		strtotime: function (text, now) {
			return strtotime(text, now)
		},


		/**
		 * Check if the specified timezone is valid
		 *
		 * @param value
		 * @returns {boolean}
		 */
		isTimezone: function (value) {
			var timezones = ["Africa/Abidjan","Africa/Accra","Africa/Addis_Ababa","Africa/Algiers","Africa/Asmara","Africa/Bamako","Africa/Bangui","Africa/Banjul","Africa/Bissau","Africa/Blantyre","Africa/Brazzaville","Africa/Bujumbura","Africa/Cairo","Africa/Casablanca","Africa/Ceuta","Africa/Conakry","Africa/Dakar","Africa/Dar_es_Salaam","Africa/Djibouti","Africa/Douala","Africa/El_Aaiun","Africa/Freetown","Africa/Gaborone","Africa/Harare","Africa/Johannesburg","Africa/Juba","Africa/Kampala","Africa/Khartoum","Africa/Kigali","Africa/Kinshasa","Africa/Lagos","Africa/Libreville","Africa/Lome","Africa/Luanda","Africa/Lubumbashi","Africa/Lusaka","Africa/Malabo","Africa/Maputo","Africa/Maseru","Africa/Mbabane","Africa/Mogadishu","Africa/Monrovia","Africa/Nairobi","Africa/Ndjamena","Africa/Niamey","Africa/Nouakchott","Africa/Ouagadougou","Africa/Porto-Novo","Africa/Sao_Tome","Africa/Tripoli","Africa/Tunis","Africa/Windhoek","America/Adak","America/Anchorage","America/Anguilla","America/Antigua","America/Araguaina","America/Argentina/Buenos_Aires","America/Argentina/Catamarca","America/Argentina/Cordoba","America/Argentina/Jujuy","America/Argentina/La_Rioja","America/Argentina/Mendoza","America/Argentina/Rio_Gallegos","America/Argentina/Salta","America/Argentina/San_Juan","America/Argentina/San_Luis","America/Argentina/Tucuman","America/Argentina/Ushuaia","America/Aruba","America/Asuncion","America/Atikokan","America/Bahia","America/Bahia_Banderas","America/Barbados","America/Belem","America/Belize","America/Blanc-Sablon","America/Boa_Vista","America/Bogota","America/Boise","America/Cambridge_Bay","America/Campo_Grande","America/Cancun","America/Caracas","America/Cayenne","America/Cayman","America/Chicago","America/Chihuahua","America/Costa_Rica","America/Creston","America/Cuiaba","America/Curacao","America/Danmarkshavn","America/Dawson","America/Dawson_Creek","America/Denver","America/Detroit","America/Dominica","America/Edmonton","America/Eirunepe","America/El_Salvador","America/Fortaleza","America/Glace_Bay","America/Godthab","America/Goose_Bay","America/Grand_Turk","America/Grenada","America/Guadeloupe","America/Guatemala","America/Guayaquil","America/Guyana","America/Halifax","America/Havana","America/Hermosillo","America/Indiana/Indianapolis","America/Indiana/Knox","America/Indiana/Marengo","America/Indiana/Petersburg","America/Indiana/Tell_City","America/Indiana/Vevay","America/Indiana/Vincennes","America/Indiana/Winamac","America/Inuvik","America/Iqaluit","America/Jamaica","America/Juneau","America/Kentucky/Louisville","America/Kentucky/Monticello","America/Kralendijk","America/La_Paz","America/Lima","America/Los_Angeles","America/Lower_Princes","America/Maceio","America/Managua","America/Manaus","America/Marigot","America/Martinique","America/Matamoros","America/Mazatlan","America/Menominee","America/Merida","America/Metlakatla","America/Mexico_City","America/Miquelon","America/Moncton","America/Monterrey","America/Montevideo","America/Montserrat","America/Nassau","America/New_York","America/Nipigon","America/Nome","America/Noronha","America/North_Dakota/Beulah","America/North_Dakota/Center","America/North_Dakota/New_Salem","America/Ojinaga","America/Panama","America/Pangnirtung","America/Paramaribo","America/Phoenix","America/Port-au-Prince","America/Port_of_Spain","America/Porto_Velho","America/Puerto_Rico","America/Rainy_River","America/Rankin_Inlet","America/Recife","America/Regina","America/Resolute","America/Rio_Branco","America/Santa_Isabel","America/Santarem","America/Santiago","America/Santo_Domingo","America/Sao_Paulo","America/Scoresbysund","America/Sitka","America/St_Barthelemy","America/St_Johns","America/St_Kitts","America/St_Lucia","America/St_Thomas","America/St_Vincent","America/Swift_Current","America/Tegucigalpa","America/Thule","America/Thunder_Bay","America/Tijuana","America/Toronto","America/Tortola","America/Vancouver","America/Whitehorse","America/Winnipeg","America/Yakutat","America/Yellowknife","Antarctica/Casey","Antarctica/Davis","Antarctica/DumontDUrville","Antarctica/Macquarie","Antarctica/Mawson","Antarctica/McMurdo","Antarctica/Palmer","Antarctica/Rothera","Antarctica/Syowa","Antarctica/Troll","Antarctica/Vostok","Arctic/Longyearbyen","Asia/Aden","Asia/Almaty","Asia/Amman","Asia/Anadyr","Asia/Aqtau","Asia/Aqtobe","Asia/Ashgabat","Asia/Baghdad","Asia/Bahrain","Asia/Baku","Asia/Bangkok","Asia/Beirut","Asia/Bishkek","Asia/Brunei","Asia/Choibalsan","Asia/Chongqing","Asia/Colombo","Asia/Damascus","Asia/Dhaka","Asia/Dili","Asia/Dubai","Asia/Dushanbe","Asia/Gaza","Asia/Harbin","Asia/Hebron","Asia/Ho_Chi_Minh","Asia/Hong_Kong","Asia/Hovd","Asia/Irkutsk","Asia/Jakarta","Asia/Jayapura","Asia/Jerusalem","Asia/Kabul","Asia/Kamchatka","Asia/Karachi","Asia/Kashgar","Asia/Kathmandu","Asia/Khandyga","Asia/Kolkata","Asia/Krasnoyarsk","Asia/Kuala_Lumpur","Asia/Kuching","Asia/Kuwait","Asia/Macau","Asia/Magadan","Asia/Makassar","Asia/Manila","Asia/Muscat","Asia/Nicosia","Asia/Novokuznetsk","Asia/Novosibirsk","Asia/Omsk","Asia/Oral","Asia/Phnom_Penh","Asia/Pontianak","Asia/Pyongyang","Asia/Qatar","Asia/Qyzylorda","Asia/Rangoon","Asia/Riyadh","Asia/Sakhalin","Asia/Samarkand","Asia/Seoul","Asia/Shanghai","Asia/Singapore","Asia/Taipei","Asia/Tashkent","Asia/Tbilisi","Asia/Tehran","Asia/Thimphu","Asia/Tokyo","Asia/Ulaanbaatar","Asia/Urumqi","Asia/Ust-Nera","Asia/Vientiane","Asia/Vladivostok","Asia/Yakutsk","Asia/Yekaterinburg","Asia/Yerevan","Atlantic/Azores","Atlantic/Bermuda","Atlantic/Canary","Atlantic/Cape_Verde","Atlantic/Faroe","Atlantic/Madeira","Atlantic/Reykjavik","Atlantic/South_Georgia","Atlantic/St_Helena","Atlantic/Stanley","Australia/Adelaide","Australia/Brisbane","Australia/Broken_Hill","Australia/Currie","Australia/Darwin","Australia/Eucla","Australia/Hobart","Australia/Lindeman","Australia/Lord_Howe","Australia/Melbourne","Australia/Perth","Australia/Sydney","Europe/Amsterdam","Europe/Andorra","Europe/Athens","Europe/Belgrade","Europe/Berlin","Europe/Bratislava","Europe/Brussels","Europe/Bucharest","Europe/Budapest","Europe/Busingen","Europe/Chisinau","Europe/Copenhagen","Europe/Dublin","Europe/Gibraltar","Europe/Guernsey","Europe/Helsinki","Europe/Isle_of_Man","Europe/Istanbul","Europe/Jersey","Europe/Kaliningrad","Europe/Kiev","Europe/Lisbon","Europe/Ljubljana","Europe/London","Europe/Luxembourg","Europe/Madrid","Europe/Malta","Europe/Mariehamn","Europe/Minsk","Europe/Monaco","Europe/Moscow","Europe/Oslo","Europe/Paris","Europe/Podgorica","Europe/Prague","Europe/Riga","Europe/Rome","Europe/Samara","Europe/San_Marino","Europe/Sarajevo","Europe/Simferopol","Europe/Skopje","Europe/Sofia","Europe/Stockholm","Europe/Tallinn","Europe/Tirane","Europe/Uzhgorod","Europe/Vaduz","Europe/Vatican","Europe/Vienna","Europe/Vilnius","Europe/Volgograd","Europe/Warsaw","Europe/Zagreb","Europe/Zaporozhye","Europe/Zurich","Indian/Antananarivo","Indian/Chagos","Indian/Christmas","Indian/Cocos","Indian/Comoro","Indian/Kerguelen","Indian/Mahe","Indian/Maldives","Indian/Mauritius","Indian/Mayotte","Indian/Reunion","Pacific/Apia","Pacific/Auckland","Pacific/Chatham","Pacific/Chuuk","Pacific/Easter","Pacific/Efate","Pacific/Enderbury","Pacific/Fakaofo","Pacific/Fiji","Pacific/Funafuti","Pacific/Galapagos","Pacific/Gambier","Pacific/Guadalcanal","Pacific/Guam","Pacific/Honolulu","Pacific/Johnston","Pacific/Kiritimati","Pacific/Kosrae","Pacific/Kwajalein","Pacific/Majuro","Pacific/Marquesas","Pacific/Midway","Pacific/Nauru","Pacific/Niue","Pacific/Norfolk","Pacific/Noumea","Pacific/Pago_Pago","Pacific/Palau","Pacific/Pitcairn","Pacific/Pohnpei","Pacific/Port_Moresby","Pacific/Rarotonga","Pacific/Saipan","Pacific/Tahiti","Pacific/Tarawa","Pacific/Tongatapu","Pacific/Wake","Pacific/Wallis","UTC"];
			return timezones.indexOf(value)!=-1;
		}
	}
});
/*!
 * Laravel Javascript Validation
 *
 * https://github.com/proengsoft/laravel-jsvalidation
 *
 * Timezone Helper functions used by validators
 *
 * Copyright (c) 2014 Proengsoft
 * Released under the MIT license
 */

$.extend(true, laravelValidation, {

	helpers: {

		/**
		 * Check if the specified timezone is valid
		 *
		 * @param value
		 * @returns {boolean}
		 */
		isTimezone: function (value) {

			var timezones={
				"africa": [
					"abidjan",
					"accra",
					"addis_ababa",
					"algiers",
					"asmara",
					"bamako",
					"bangui",
					"banjul",
					"bissau",
					"blantyre",
					"brazzaville",
					"bujumbura",
					"cairo",
					"casablanca",
					"ceuta",
					"conakry",
					"dakar",
					"dar_es_salaam",
					"djibouti",
					"douala",
					"el_aaiun",
					"freetown",
					"gaborone",
					"harare",
					"johannesburg",
					"juba",
					"kampala",
					"khartoum",
					"kigali",
					"kinshasa",
					"lagos",
					"libreville",
					"lome",
					"luanda",
					"lubumbashi",
					"lusaka",
					"malabo",
					"maputo",
					"maseru",
					"mbabane",
					"mogadishu",
					"monrovia",
					"nairobi",
					"ndjamena",
					"niamey",
					"nouakchott",
					"ouagadougou",
					"porto-novo",
					"sao_tome",
					"tripoli",
					"tunis",
					"windhoek"
				],
				"america": [
					"adak",
					"anchorage",
					"anguilla",
					"antigua",
					"araguaina",
					"argentina\/buenos_aires",
					"argentina\/catamarca",
					"argentina\/cordoba",
					"argentina\/jujuy",
					"argentina\/la_rioja",
					"argentina\/mendoza",
					"argentina\/rio_gallegos",
					"argentina\/salta",
					"argentina\/san_juan",
					"argentina\/san_luis",
					"argentina\/tucuman",
					"argentina\/ushuaia",
					"aruba",
					"asuncion",
					"atikokan",
					"bahia",
					"bahia_banderas",
					"barbados",
					"belem",
					"belize",
					"blanc-sablon",
					"boa_vista",
					"bogota",
					"boise",
					"cambridge_bay",
					"campo_grande",
					"cancun",
					"caracas",
					"cayenne",
					"cayman",
					"chicago",
					"chihuahua",
					"costa_rica",
					"creston",
					"cuiaba",
					"curacao",
					"danmarkshavn",
					"dawson",
					"dawson_creek",
					"denver",
					"detroit",
					"dominica",
					"edmonton",
					"eirunepe",
					"el_salvador",
					"fortaleza",
					"glace_bay",
					"godthab",
					"goose_bay",
					"grand_turk",
					"grenada",
					"guadeloupe",
					"guatemala",
					"guayaquil",
					"guyana",
					"halifax",
					"havana",
					"hermosillo",
					"indiana\/indianapolis",
					"indiana\/knox",
					"indiana\/marengo",
					"indiana\/petersburg",
					"indiana\/tell_city",
					"indiana\/vevay",
					"indiana\/vincennes",
					"indiana\/winamac",
					"inuvik",
					"iqaluit",
					"jamaica",
					"juneau",
					"kentucky\/louisville",
					"kentucky\/monticello",
					"kralendijk",
					"la_paz",
					"lima",
					"los_angeles",
					"lower_princes",
					"maceio",
					"managua",
					"manaus",
					"marigot",
					"martinique",
					"matamoros",
					"mazatlan",
					"menominee",
					"merida",
					"metlakatla",
					"mexico_city",
					"miquelon",
					"moncton",
					"monterrey",
					"montevideo",
					"montreal",
					"montserrat",
					"nassau",
					"new_york",
					"nipigon",
					"nome",
					"noronha",
					"north_dakota\/beulah",
					"north_dakota\/center",
					"north_dakota\/new_salem",
					"ojinaga",
					"panama",
					"pangnirtung",
					"paramaribo",
					"phoenix",
					"port-au-prince",
					"port_of_spain",
					"porto_velho",
					"puerto_rico",
					"rainy_river",
					"rankin_inlet",
					"recife",
					"regina",
					"resolute",
					"rio_branco",
					"santa_isabel",
					"santarem",
					"santiago",
					"santo_domingo",
					"sao_paulo",
					"scoresbysund",
					"shiprock",
					"sitka",
					"st_barthelemy",
					"st_johns",
					"st_kitts",
					"st_lucia",
					"st_thomas",
					"st_vincent",
					"swift_current",
					"tegucigalpa",
					"thule",
					"thunder_bay",
					"tijuana",
					"toronto",
					"tortola",
					"vancouver",
					"whitehorse",
					"winnipeg",
					"yakutat",
					"yellowknife"
				],
				"antarctica": [
					"casey",
					"davis",
					"dumontdurville",
					"macquarie",
					"mawson",
					"mcmurdo",
					"palmer",
					"rothera",
					"south_pole",
					"syowa",
					"vostok"
				],
				"arctic": [
					"longyearbyen"
				],
				"asia": [
					"aden",
					"almaty",
					"amman",
					"anadyr",
					"aqtau",
					"aqtobe",
					"ashgabat",
					"baghdad",
					"bahrain",
					"baku",
					"bangkok",
					"beirut",
					"bishkek",
					"brunei",
					"choibalsan",
					"chongqing",
					"colombo",
					"damascus",
					"dhaka",
					"dili",
					"dubai",
					"dushanbe",
					"gaza",
					"harbin",
					"hebron",
					"ho_chi_minh",
					"hong_kong",
					"hovd",
					"irkutsk",
					"jakarta",
					"jayapura",
					"jerusalem",
					"kabul",
					"kamchatka",
					"karachi",
					"kashgar",
					"kathmandu",
					"khandyga",
					"kolkata",
					"krasnoyarsk",
					"kuala_lumpur",
					"kuching",
					"kuwait",
					"macau",
					"magadan",
					"makassar",
					"manila",
					"muscat",
					"nicosia",
					"novokuznetsk",
					"novosibirsk",
					"omsk",
					"oral",
					"phnom_penh",
					"pontianak",
					"pyongyang",
					"qatar",
					"qyzylorda",
					"rangoon",
					"riyadh",
					"sakhalin",
					"samarkand",
					"seoul",
					"shanghai",
					"singapore",
					"taipei",
					"tashkent",
					"tbilisi",
					"tehran",
					"thimphu",
					"tokyo",
					"ulaanbaatar",
					"urumqi",
					"ust-nera",
					"vientiane",
					"vladivostok",
					"yakutsk",
					"yekaterinburg",
					"yerevan"
				],
				"atlantic": [
					"azores",
					"bermuda",
					"canary",
					"cape_verde",
					"faroe",
					"madeira",
					"reykjavik",
					"south_georgia",
					"st_helena",
					"stanley"
				],
				"australia": [
					"adelaide",
					"brisbane",
					"broken_hill",
					"currie",
					"darwin",
					"eucla",
					"hobart",
					"lindeman",
					"lord_howe",
					"melbourne",
					"perth",
					"sydney"
				],
				"europe": [
					"amsterdam",
					"andorra",
					"athens",
					"belgrade",
					"berlin",
					"bratislava",
					"brussels",
					"bucharest",
					"budapest",
					"busingen",
					"chisinau",
					"copenhagen",
					"dublin",
					"gibraltar",
					"guernsey",
					"helsinki",
					"isle_of_man",
					"istanbul",
					"jersey",
					"kaliningrad",
					"kiev",
					"lisbon",
					"ljubljana",
					"london",
					"luxembourg",
					"madrid",
					"malta",
					"mariehamn",
					"minsk",
					"monaco",
					"moscow",
					"oslo",
					"paris",
					"podgorica",
					"prague",
					"riga",
					"rome",
					"samara",
					"san_marino",
					"sarajevo",
					"simferopol",
					"skopje",
					"sofia",
					"stockholm",
					"tallinn",
					"tirane",
					"uzhgorod",
					"vaduz",
					"vatican",
					"vienna",
					"vilnius",
					"volgograd",
					"warsaw",
					"zagreb",
					"zaporozhye",
					"zurich"
				],
				"indian": [
					"antananarivo",
					"chagos",
					"christmas",
					"cocos",
					"comoro",
					"kerguelen",
					"mahe",
					"maldives",
					"mauritius",
					"mayotte",
					"reunion"
				],
				"pacific": [
					"apia",
					"auckland",
					"chatham",
					"chuuk",
					"easter",
					"efate",
					"enderbury",
					"fakaofo",
					"fiji",
					"funafuti",
					"galapagos",
					"gambier",
					"guadalcanal",
					"guam",
					"honolulu",
					"johnston",
					"kiritimati",
					"kosrae",
					"kwajalein",
					"majuro",
					"marquesas",
					"midway",
					"nauru",
					"niue",
					"norfolk",
					"noumea",
					"pago_pago",
					"palau",
					"pitcairn",
					"pohnpei",
					"port_moresby",
					"rarotonga",
					"saipan",
					"tahiti",
					"tarawa",
					"tongatapu",
					"wake",
					"wallis"
				],
				"utc": [
					""
				]
			};

			var tzparts= value.split('/',2);
			var continent=tzparts[0].toLowerCase();
			var city='';
			if (tzparts[1]) {
				city=tzparts[1].toLowerCase();
			}

			return (continent in timezones && ( timezones[continent].length==0 || timezones[continent].indexOf(city)!=-1))

		}
	}


});
/*!
 * Laravel Javascript Validation
 *
 * https://github.com/proengsoft/laravel-jsvalidation
 *
 * Metjods that implement Laravel Validations
 *
 * Copyright (c) 2014 Proengsoft
 * Released under the MIT license
 */


$.extend(true, laravelValidation, {

	methods: function(){

		var helpers=laravelValidation.helpers;

		/**
		 * "Validate" optional attributes.
		 * Always returns true, just lets us put sometimes in rules.*
		 */
		$.validator.addMethod("laravelSometimes", function(value, element, params) {
			return true;
		}, $.validator.format(""));

		/**
		 * Validate the given attribute is filled if it is present.
		 */
		$.validator.addMethod("laravelFilled", function(value, element, params) {
			return $.validator.methods.required.call(this, value, element, true);
		}, $.validator.format("The field is required"));

		/**
		 *Validate that a required attribute exists.
		 */
		$.validator.addMethod("laravelRequired", function(value, element, params) {
			return $.validator.methods.required.call(this, value, element, true);
		}, $.validator.format("The field is required."));

		/**
		 * Validate that an attribute exists when any other attribute exists.
		 */
		$.validator.addMethod("laravelRequiredWith", function(value, element, params) {
			var validator=this,
				required=false;
			$.each(params,function(i,param) {
				var $el = helpers.getElement(element,param);
				required=required || $el==false || $.validator.methods.required.call(validator, $el.val(),$el[0],true);
			});
			if (required) {
				return  $.validator.methods.required.call(this, value, element, true);
			}
			return true;
		}, $.validator.format("The field is required when any of {0} {1} {2} {3} is present."));

		/**
		 * Validate that an attribute exists when all other attribute exists.
		 */
		$.validator.addMethod("laravelRequiredWithAll", function(value, element, params) {
			var validator=this,
				required=true;
			$.each(params,function(i,param) {
				var $el = helpers.getElement(element,param);
				required=required && ($el==false || $.validator.methods.required.call(validator, $el.val(),$el[0],true));
			});
			if (required) {
				return  $.validator.methods.required.call(this, value, element, true);
			}
			return true;
		}, $.validator.format("The field is required when {0} {1} {2} {3} is present."));

		/**
		 * Validate that an attribute exists when any other attribute does not exists.
		 */
		$.validator.addMethod("laravelRequiredWithout", function(value, element, params) {
			return  ! $.validator.methods.laravelRequiredWith.call(this, value, element,params );
		}, $.validator.format("The field is required when any of {0} {1} {2} {3} is not present."));

		/**
		 * Validate that an attribute exists when all other attribute does not exists.
		 */
		$.validator.addMethod("laravelRequiredWithoutAll", function(value, element, params) {
			return  ! $.validator.methods.laravelRequiredWithAll.call(this, value, element,params );
		}, $.validator.format("The field is required when {0} {1} {2} {3} is present."));

		/**
		 * Validate that an attribute exists when another attribute has a given value.
		 */
		$.validator.addMethod("laravelRequiredIf", function(value, element, params) {
			var $el = helpers.getElement(element,params[0]);
			if ($el==false) {
				return true;
			} else if ($el.val()==params[1]) {
				return $.validator.methods.required.call(this, value, element, true);
			} else {
				return true;
			}

		}, $.validator.format("The :attribute field is required when {0} is {1}."));

		/**
		 * Validate that an attribute has a matching confirmation.
		 */
		$.validator.addMethod("laravelConfirmed", function(value, element, params) {
			return $.validator.methods.equalTo.call(this, value, element, helpers.selector(params[0]));
		}, $.validator.format("The field confirmation does not match."));

		/**
		 * Validate that two attributes match.
		 */
		$.validator.addMethod("laravelSame", function(value, element, params) {
			return this.optional(element) ||
				$.validator.methods.equalTo.call(this, value, element, helpers.selector(params));
		}, $.validator.format("The field must match with {0}"));

		/**
		 * Validate that an attribute is different from another attribute.
		 */
		$.validator.addMethod("laravelDifferent", function(value, element, params) {
			return this.optional(element) ||
				! $.validator.methods.equalTo.call(this, value, element, helpers.selector(params));
		}, $.validator.format("The field and {0} must be different."));

		/**
		 * Validate that an attribute was "accepted".
		 * This validation rule implies the attribute is "required".
		 */
		$.validator.addMethod("laravelAccepted", function(value, element, params) {
			var regex = new RegExp("^(?:(yes|on|1|true))$",'i');
			return regex.test(value);
		}, $.validator.format("The field must be accepted."));

		/**
		 * Validate that an attribute is an array.
		 */
		$.validator.addMethod("laravelArray", function(value, element, params) {
			return this.optional(element) ||
				$.isArray(value);
		}, $.validator.format("The :attribute must be an array."));

		/**
		 * Validate that an attribute is a boolean.
		 */
		$.validator.addMethod("laravelBoolean", function(value, element, params) {
			var regex= new RegExp("^(?:(true|false|1|0))$",'i');
			return this.optional(element) ||  regex.test(value);
		}, $.validator.format("The field must be true or false"));

		/**
		 * Validate that an attribute is an integer.
		 */
		$.validator.addMethod("laravelInteger", function(value, element, params) {
			var regex= new RegExp("^(?:-?\\d+)$",'i');
			return this.optional(element) ||  regex.test(value);
		}, $.validator.format("The field must be must be a integer."));

		/**
		 * Validate that an attribute is numeric.
		 */
		$.validator.addMethod("laravelNumeric", function(value, element, params) {
			return this.optional(element) ||
				$.validator.methods.number.call(this, value, element, true);
		}, $.validator.format("The field must be must be a number."));

		/**
		 * Validate that an attribute is a string.
		 */
		$.validator.addMethod("laravelString", function(value, element, params) {
			return this.optional(element) ||
				typeof value == 'string';
		}, $.validator.format("The field must be string"));

		/**
		 * The field under validation must be numeric and must have an exact length of value.
		 */
		$.validator.addMethod("laravelDigits", function(value, element, params) {
			return this.optional(element) ||
				($.validator.methods.number.call(this, value, element, true)
				&& value.length==params);
		}, $.validator.format("The field must be {0} digits."));

		/**
		 * The field under validation must have a length between the given min and max.
		 */
		$.validator.addMethod("laravelDigitsBetween", function(value, element, params) {
			return this.optional(element) ||
				($.validator.methods.number.call(this, value, element, true)
				&& value.length>=params[0] && value.length<=params[1]);
		}, $.validator.format("The field must be beetwen {0} and {1} digits."));

		/**
		 * Validate the size of an attribute.
		 */
		$.validator.addMethod("laravelSize", function(value, element, params) {
			return this.optional(element) ||
				helpers.getSize(this, element,value) == params[0];
		}, $.validator.format("The field must be {0}"));

		/**
		 * Validate the size of an attribute is between a set of values.
		 */
		$.validator.addMethod("laravelBetween", function(value, element, params) {
			return this.optional(element) ||
				( helpers.getSize(this, element,value) >= params[0] && helpers.getSize(this,element,value) <= params[1]);
		}, $.validator.format("The field must be between {0} and {1}"));

		/**
		 * Validate the size of an attribute is greater than a minimum value.
		 */
		$.validator.addMethod("laravelMin", function(value, element, params) {
			return this.optional(element) ||
				helpers.getSize(this, element,value) >= params[0];
		}, $.validator.format("The field must be at least {0}"));

		/**
		 * Validate the size of an attribute is less than a maximum value.
		 */
		$.validator.addMethod("laravelMax", function(value, element, params) {
			return this.optional(element) ||
				helpers.getSize(this, element,value) <= params[0];
		}, $.validator.format("The field may not be greater than {0}"));

		/**
		 *  Validate an attribute is contained within a list of values.
		 */
		$.validator.addMethod("laravelIn", function(value, element, params) {
			return this.optional(element) ||
				params.indexOf(value.toString()) != -1;
		}, $.validator.format("The selected :attribute is invalid"));

		/**
		 *  Validate an attribute is not contained within a list of values.
		 */
		$.validator.addMethod("laravelNotIn", function(value, element, params) {
			return this.optional(element) ||
				params.indexOf(value.toString()) == -1;
		}, $.validator.format("The selected :attribute is invalid"));

		/**
		 *  Validate the uniqueness of an attribute value on a given database table.
		 */
		$.validator.addMethod("laravelUnique", function(value, element, params) {
			return this.optional(element) || true;
		}, $.validator.format("Not implemented"));

		/**
		 *  Validate the existence of an attribute value in a database table.
		 */
		$.validator.addMethod("laravelExists", function(value, element, params) {
			return this.optional(element) || true;
		}, $.validator.format("Not implemented"));

		/**
		 *  Validate that an attribute is a valid IP.
		 */
		$.validator.addMethod("laravelIp", function(value, element, params) {
			return this.optional(element) ||
				/^(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)\.(25[0-5]|2[0-4]\d|[01]?\d\d?)$/i.test(value) ||
				/^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i.test(value);
		}, $.validator.format("The :attribute must be a valid IP address."));

		/**
		 *  Validate that an attribute is a valid e-mail address.
		 */
		$.validator.addMethod("laravelEmail", function(value, element, params) {
			return this.optional(element) ||
				$.validator.methods.email.call(this, value, element, true);
		}, $.validator.format("The :attribute must be a valid email address."));

		/**
		 * Validate that an attribute is a valid URL.
		 */
		$.validator.addMethod("laravelUrl", function(value, element, params) {
			return this.optional( element ) ||
				/^(https?|s?ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test( value );
		}, $.validator.format("The :attribute format is invalid"));

		/**
		 * Validate that an attribute is an active URL.
		 */
		$.validator.addMethod("laravelActiveUrl", function(value, element, params) {
			return $.validator.methods.laravelUrl.call(this, value, element, true);
		}, $.validator.format("The :attribute is not a valid URL."));

		/**
		 * Validate the MIME type of a file upload attribute is in a set of MIME types.
		 */
		$.validator.addMethod("laravelImage", function(value, element, params) {
			return $.validator.methods.laravelMimes.call(this, value, element, ['jpg', 'png', 'gif', 'bmp', 'svg']);
		}, $.validator.format("The :attribute must be a file of type: {0}."));


		/**
		 * Validate the MIME type of a file upload attribute is in a set of MIME types.
		 */
		$.validator.addMethod("laravelMimes", function(value, element, params) {
			return this.optional(element) ||
				(!window.File || !window.FileReader || !window.FileList || !window.Blob) ||
				params.indexOf(helpers.fileinfo(element).extension)!=-1;
		}, $.validator.format("The :attribute must be a file of type: {0}."));

		/**
		 * Validate that an attribute contains only alphabetic characters.
		 */
		$.validator.addMethod("laravelAlpha", function(value, element, params) {
			var regex = new RegExp("^(?:^[a-z]+$)$",'i');
			return this.optional(element) || regex.test(value);

		}, $.validator.format("The :attribute may only contain letters."));

		/**
		 * Validate that an attribute contains only alpha-numeric characters.
		 */
		$.validator.addMethod("laravelAlphaNum", function(value, element, params) {
			var regex = new RegExp("^(?:^[a-z0-9]+$)$",'i');
			return  this.optional(element) || regex.test(value);
		}, $.validator.format("The :attribute may only contain letters and numbers."));

		/**
		 * Validate that an attribute contains only alphabetic characters.
		 */
		$.validator.addMethod("laravelAlphaDash", function(value, element, params) {
			var regex = new RegExp("^(?:^[\\w\\-_]+$)$",'i');
			return  this.optional(element) || regex.test(value);
		}, $.validator.format("The :attribute may only contain letters, numbers, and dashes."));

		/**
		 * Validate that an attribute passes a regular expression check.
		 */
		$.validator.addMethod("laravelRegex", function(value, element, params) {
			var invalidModifiers=['x','s','u','X','U','A'];
			// Converting php regular expression
			var phpReg= new RegExp('^(?:\/)(.*\\\/?[^\/]*|[^\/]*)(?:\/)([gmixXsuUAJ]*)?$');
			var matches=params[0].match(phpReg);
			if (matches==null) return false;
			// checking modifiers
			var php_modifiers=[];
			if (matches[2]!=undefined) {
				php_modifiers=matches[2].split('');
				for (var i=0; i<php_modifiers.length<i ;i++) {
					if (invalidModifiers.indexOf(php_modifiers[i])!=-1) {
						return true;
					}
				}
			}
			var regex = new RegExp("^(?:"+matches[1]+")$",php_modifiers.join());
			return  this.optional(element) || regex.test(value);
		}, $.validator.format("The :attribute format is invalid."));

		/**
		 * Validate that an attribute is a valid date.
		 */
		$.validator.addMethod("laravelDate", function(value, element, params) {
			return this.optional(element) ||(helpers.strtotime(value)!=false);
		}, $.validator.format("The :attribute is not a valid date"));

		/**
		 * Validate that an attribute matches a date format.
		 */
		$.validator.addMethod("laravelDateFormat", function(value, element, params) {
			return this.optional(element) || helpers.parseTime(value,params[0])!=false;
		}, $.validator.format("The :attribute does not match the format {0)"));

		/**
		 * Validate the date is before a given date.
		 */
		$.validator.addMethod("laravelBefore", function(value, element, params) {
			var timeValue=helpers.parseTime(value, element);
			return this.optional(element) || (timeValue !=false && timeValue < params[0]);
		}, $.validator.format("The :attribute must be a date before {0}."));

		/**
		 * Validate the date is after a given date.
		 */
		$.validator.addMethod("laravelAfter", function(value, element, params) {
			var timeValue=helpers.parseTime(value, element);
			return this.optional(element) || (timeValue !=false && timeValue > params[0]);
		}, $.validator.format("The :attribute must be a date after {0}."));

		/**
		 * Validate that an attribute is a valid date.
		 */
		$.validator.addMethod("laravelTimezone", function(value, element, params) {
			return this.optional(element) || helpers.isTimezone(value);
		}, $.validator.format("The :attribute is not a valid date"));
	}

});

//# sourceMappingURL=jsvalidation.js.map